"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateErrorName = generateErrorName;
exports.default = Lint;

var _providers = require("./providers");

function generateErrorName(_node) {
  if (_node.name) return _node.name;
  if (_node.property) return `${_node.object}.${_node.property}()`;
  return _node.object;
}
/**
 * Return false if a if a rule fails
 *
 * TODO: Eventually, targets will default to 'modern', ('chrome@50', safari@8)
 *       See https://github.com/amilajack/eslint-plugin-compat/wiki#release-200
 */


function Lint(eslintNode, targets = ['chrome', 'firefox', 'safari', 'edge'], polyfills) {
  // Find the corresponding rules for a eslintNode by it's astNodeType
  const failingRule = _providers.rules.filter(rule => rule.astNodeType === eslintNode.type && // v2 allowed users to select polyfills based off their caniuseId. This is
  // no longer supported. Keeping this here to avoid breaking changes.
  !polyfills.has(rule.id) && // Check if polyfill is provided (ex. `Promise.all`)
  !polyfills.has(rule.protoChainId) && // Check if entire API is polyfilled (ex. `Promise`)
  !polyfills.has(rule.protoChain[0])) // Find the first failing rule
  .find(rule => !rule.isValid(rule, eslintNode, targets));

  return failingRule ? {
    rule: failingRule,
    isValid: false,
    unsupportedTargets: failingRule.getUnsupportedTargets(failingRule, targets)
  } : {
    rule: {},
    unsupportedTargets: [],
    isValid: true
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9MaW50LmpzIl0sIm5hbWVzIjpbImdlbmVyYXRlRXJyb3JOYW1lIiwiX25vZGUiLCJuYW1lIiwicHJvcGVydHkiLCJvYmplY3QiLCJMaW50IiwiZXNsaW50Tm9kZSIsInRhcmdldHMiLCJwb2x5ZmlsbHMiLCJmYWlsaW5nUnVsZSIsInJ1bGVzIiwiZmlsdGVyIiwicnVsZSIsImFzdE5vZGVUeXBlIiwidHlwZSIsImhhcyIsImlkIiwicHJvdG9DaGFpbklkIiwicHJvdG9DaGFpbiIsImZpbmQiLCJpc1ZhbGlkIiwidW5zdXBwb3J0ZWRUYXJnZXRzIiwiZ2V0VW5zdXBwb3J0ZWRUYXJnZXRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOztBQUdPLFNBQVNBLGlCQUFULENBQTJCQyxLQUEzQixFQUFnRDtBQUNyRCxNQUFJQSxLQUFLLENBQUNDLElBQVYsRUFBZ0IsT0FBT0QsS0FBSyxDQUFDQyxJQUFiO0FBQ2hCLE1BQUlELEtBQUssQ0FBQ0UsUUFBVixFQUFvQixPQUFRLEdBQUVGLEtBQUssQ0FBQ0csTUFBTyxJQUFHSCxLQUFLLENBQUNFLFFBQVMsSUFBekM7QUFDcEIsU0FBT0YsS0FBSyxDQUFDRyxNQUFiO0FBQ0Q7QUFFRDs7Ozs7Ozs7QUFNZSxTQUFTQyxJQUFULENBQ2JDLFVBRGEsRUFFYkMsT0FBZ0IsR0FBRyxDQUFDLFFBQUQsRUFBVyxTQUFYLEVBQXNCLFFBQXRCLEVBQWdDLE1BQWhDLENBRk4sRUFHYkMsU0FIYSxFQUlFO0FBQ2Y7QUFDQSxRQUFNQyxXQUFXLEdBQUdDLGlCQUNqQkMsTUFEaUIsQ0FFZkMsSUFBRCxJQUNFQSxJQUFJLENBQUNDLFdBQUwsS0FBcUJQLFVBQVUsQ0FBQ1EsSUFBaEMsSUFDQTtBQUNBO0FBQ0EsR0FBQ04sU0FBUyxDQUFDTyxHQUFWLENBQWNILElBQUksQ0FBQ0ksRUFBbkIsQ0FIRCxJQUlBO0FBQ0EsR0FBQ1IsU0FBUyxDQUFDTyxHQUFWLENBQWNILElBQUksQ0FBQ0ssWUFBbkIsQ0FMRCxJQU1BO0FBQ0EsR0FBQ1QsU0FBUyxDQUFDTyxHQUFWLENBQWNILElBQUksQ0FBQ00sVUFBTCxDQUFnQixDQUFoQixDQUFkLENBVmEsRUFZbEI7QUFaa0IsR0FhakJDLElBYmlCLENBYVhQLElBQUQsSUFBeUIsQ0FBQ0EsSUFBSSxDQUFDUSxPQUFMLENBQWFSLElBQWIsRUFBbUJOLFVBQW5CLEVBQStCQyxPQUEvQixDQWJkLENBQXBCOztBQWVBLFNBQU9FLFdBQVcsR0FDZDtBQUNFRyxJQUFBQSxJQUFJLEVBQUVILFdBRFI7QUFFRVcsSUFBQUEsT0FBTyxFQUFFLEtBRlg7QUFHRUMsSUFBQUEsa0JBQWtCLEVBQUVaLFdBQVcsQ0FBQ2EscUJBQVosQ0FDbEJiLFdBRGtCLEVBRWxCRixPQUZrQjtBQUh0QixHQURjLEdBU2Q7QUFDRUssSUFBQUEsSUFBSSxFQUFFLEVBRFI7QUFFRVMsSUFBQUEsa0JBQWtCLEVBQUUsRUFGdEI7QUFHRUQsSUFBQUEsT0FBTyxFQUFFO0FBSFgsR0FUSjtBQWNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB7IHJ1bGVzIH0gZnJvbSAnLi9wcm92aWRlcnMnO1xuaW1wb3J0IHR5cGUgeyBOb2RlLCBFU0xpbnROb2RlLCBUYXJnZXRzLCBpc1ZhbGlkT2JqZWN0IH0gZnJvbSAnLi9MaW50VHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVFcnJvck5hbWUoX25vZGU6IE5vZGUpOiBzdHJpbmcge1xuICBpZiAoX25vZGUubmFtZSkgcmV0dXJuIF9ub2RlLm5hbWU7XG4gIGlmIChfbm9kZS5wcm9wZXJ0eSkgcmV0dXJuIGAke19ub2RlLm9iamVjdH0uJHtfbm9kZS5wcm9wZXJ0eX0oKWA7XG4gIHJldHVybiBfbm9kZS5vYmplY3Q7XG59XG5cbi8qKlxuICogUmV0dXJuIGZhbHNlIGlmIGEgaWYgYSBydWxlIGZhaWxzXG4gKlxuICogVE9ETzogRXZlbnR1YWxseSwgdGFyZ2V0cyB3aWxsIGRlZmF1bHQgdG8gJ21vZGVybicsICgnY2hyb21lQDUwJywgc2FmYXJpQDgpXG4gKiAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FtaWxhamFjay9lc2xpbnQtcGx1Z2luLWNvbXBhdC93aWtpI3JlbGVhc2UtMjAwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbnQoXG4gIGVzbGludE5vZGU6IEVTTGludE5vZGUsXG4gIHRhcmdldHM6IFRhcmdldHMgPSBbJ2Nocm9tZScsICdmaXJlZm94JywgJ3NhZmFyaScsICdlZGdlJ10sXG4gIHBvbHlmaWxsczogU2V0PHN0cmluZz5cbik6IGlzVmFsaWRPYmplY3Qge1xuICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIHJ1bGVzIGZvciBhIGVzbGludE5vZGUgYnkgaXQncyBhc3ROb2RlVHlwZVxuICBjb25zdCBmYWlsaW5nUnVsZSA9IHJ1bGVzXG4gICAgLmZpbHRlcihcbiAgICAgIChydWxlOiBOb2RlKTogYm9vbGVhbiA9PlxuICAgICAgICBydWxlLmFzdE5vZGVUeXBlID09PSBlc2xpbnROb2RlLnR5cGUgJiZcbiAgICAgICAgLy8gdjIgYWxsb3dlZCB1c2VycyB0byBzZWxlY3QgcG9seWZpbGxzIGJhc2VkIG9mZiB0aGVpciBjYW5pdXNlSWQuIFRoaXMgaXNcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHN1cHBvcnRlZC4gS2VlcGluZyB0aGlzIGhlcmUgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcy5cbiAgICAgICAgIXBvbHlmaWxscy5oYXMocnVsZS5pZCkgJiZcbiAgICAgICAgLy8gQ2hlY2sgaWYgcG9seWZpbGwgaXMgcHJvdmlkZWQgKGV4LiBgUHJvbWlzZS5hbGxgKVxuICAgICAgICAhcG9seWZpbGxzLmhhcyhydWxlLnByb3RvQ2hhaW5JZCkgJiZcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50aXJlIEFQSSBpcyBwb2x5ZmlsbGVkIChleC4gYFByb21pc2VgKVxuICAgICAgICAhcG9seWZpbGxzLmhhcyhydWxlLnByb3RvQ2hhaW5bMF0pXG4gICAgKVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGZhaWxpbmcgcnVsZVxuICAgIC5maW5kKChydWxlOiBOb2RlKTogYm9vbGVhbiA9PiAhcnVsZS5pc1ZhbGlkKHJ1bGUsIGVzbGludE5vZGUsIHRhcmdldHMpKTtcblxuICByZXR1cm4gZmFpbGluZ1J1bGVcbiAgICA/IHtcbiAgICAgICAgcnVsZTogZmFpbGluZ1J1bGUsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB1bnN1cHBvcnRlZFRhcmdldHM6IGZhaWxpbmdSdWxlLmdldFVuc3VwcG9ydGVkVGFyZ2V0cyhcbiAgICAgICAgICBmYWlsaW5nUnVsZSxcbiAgICAgICAgICB0YXJnZXRzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgcnVsZToge30sXG4gICAgICAgIHVuc3VwcG9ydGVkVGFyZ2V0czogW10sXG4gICAgICAgIGlzVmFsaWQ6IHRydWVcbiAgICAgIH07XG59XG4iXX0=